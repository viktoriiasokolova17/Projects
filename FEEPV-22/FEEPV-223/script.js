//console.log("Hello");

/* 1 *******************************************************************************************************************/
// У JavaScript є кілька способів використання регулярних виразів. Одним із способів перевірити регулярний вираз є використання .test()методу. Метод .test()бере регулярний вираз, застосовує його до рядка (який міститься в дужках) і повертає trueабо falseякщо ваш шаблон щось знаходить чи ні.

// let testStr = "freeCodeCamp";
// let testRegex = /Code/;
// testRegex.test(testStr);
// Метод testтут повертає true.

// Застосуйте регулярний вираз myRegexдо рядка myStringза допомогою .test()методу.

// let myString = "Hello, World!";
// let myRegex = /Hello/;
// let result = myRegex.test(myString); 

/* 2 *******************************************************************************************************************/
// Зіставте літеральні рядки
// Під час останнього завдання ви шукали слово Helloза допомогою регулярного виразу /Hello/. Цей регулярний вираз шукав буквальний збіг рядка Hello. Ось ще один приклад пошуку буквального збігу рядка Kevin:

//Рішення:
// let testStr = "Hello, my name is Kevin.";
// let testRegex = /Kevin/;
// testRegex.test(testStr);
// Цей testвиклик повернеться true.

// Будь -які інші форми Kevinне підходять. Наприклад, регулярний вираз /Kevin/не відповідатиме kevinабо KEVIN.

// let wrongRegex = /kevin/;
// wrongRegex.test(testStr);
// Цей testвиклик повернеться false.

// Майбутнє завдання покаже, як відповідати цим іншим формам.

// Заповніть регулярний вираз waldoRegex, щоб знайти "Waldo"в рядку waldoIsHidingбуквальний збіг.

//Рішення:
// let waldoIsHiding = "Somewhere Waldo is hiding in this text.";
// let waldoRegex = /Waldo/; // Change this line
// let result = waldoRegex.test(waldoIsHiding);

/* 3 *******************************************************************************************************************/
// Зіставте літеральний рядок із різними можливостями
// Використовуючи такі регулярні вирази /coding/, ви можете шукати шаблон codingв іншому рядку.

// Це потужний спосіб пошуку окремих рядків, але він обмежений лише одним шаблоном. Ви можете шукати кілька шаблонів за допомогою оператора alternationабо OR: |.

// Цей оператор зіставляє шаблони до або після нього. Наприклад, якщо ви хочете зіставити рядки yesабо no, потрібним регулярним виразом є /yes|no/.

// Ви також можете шукати не лише два шаблони. Ви можете зробити це, додавши більше шаблонів із більшою кількістю ORоператорів, які їх розділяють, наприклад /yes|no|maybe/.

// Заповніть регулярний вираз petRegexвідповідно до домашніх тварин dog, cat, birdабо fish.

//Рішення:
// let petString = "James has a pet cat.";
// let petRegex = /dog|cat|bird|fish/; // Change this line
// let result = petRegex.test(petString);

/* 4 *******************************************************************************************************************/
// Ігнорувати регістр під час пошуку
// Дотепер ви розглядали регулярні вирази для буквального збігу рядків. Але іноді вам може знадобитися також зіставити відмінності регістру.

// Регістр (або іноді регістр) - це різниця між великими та малими літерами. Прикладами великих літер є A, Bі C. Прикладами нижнього регістру є a, bі c.

// Ви можете зіставити обидва випадки за допомогою так званого прапора. Є й інші прапори, але тут ви зосередитеся на прапорі, який ігнорує регістр - iпрапорі. Ви можете використовувати його, додавши до регулярного виразу. Прикладом використання цього прапора є /ignorecase/i. Цей регулярний вираз може відповідати рядкам ignorecase, igNoreCaseі IgnoreCase.

// Напишіть регулярний вираз , fccRegexякий відповідає freeCodeCamp, незалежно від регістру. Ваш регулярний вираз не повинен відповідати будь-яким скороченням або варіантам із пробілами.

// //Рішення:
// let myString = "freeCodeCamp";
// let fccRegex = /freeCodeCamp/i; // Change this line
// let result = fccRegex.test(myString);

/* 5 *******************************************************************************************************************/
// Витяг збігів
// Досі ви лише перевіряли, чи існує шаблон у рядку. Ви також можете отримати фактичні збіги, знайдені за допомогою цього .match()методу.

// Щоб використовувати .match()метод, застосуйте метод до рядка та введіть регулярний вираз у дужках.

// Ось приклад:

// "Hello, World!".match(/Hello/);
// let ourStr = "Regular expressions";
// let ourRegex = /expressions/;
// ourStr.match(ourRegex);
// matchТут повернувся б перший ["Hello"]і повернувся б другий ["expressions"].

// Зауважте, що .matchсинтаксис є «протилежністю» методу, який .testви використовували досі:

// 'string'.match(/regex/);
// /regex/.test('string');
// Застосуйте .match()метод для вилучення рядка coding.

//Рішення:
// let myString = "freeCodeCamp";
// let fccRegex = /freecodecamp/i;// Change this line
// let result = fccRegex.test(myString);

/* 6 *******************************************************************************************************************/
// Знайдіть більше, ніж перший матч
// Поки що ви могли витягнути або знайти шаблон лише один раз.

// let testStr = "Repeat, Repeat, Repeat";
// let ourRegex = /Repeat/;
// testStr.match(ourRegex);
// Ось matchповернувся б ["Repeat"].

// Щоб шукати або витягувати шаблон кілька разів, ви можете використовувати позначку глобального пошуку: g.

// let repeatRegex = /Repeat/g;
// testStr.match(repeatRegex);
// І тут matchповертає значення["Repeat", "Repeat", "Repeat"]

// Використовуючи регулярний вираз starRegex, знайдіть і витягніть обидва Twinkleслова з рядка twinkleStar.

// Примітка.
// Ви можете мати кілька позначок у своєму регулярному виразі, наприклад/search/gi

//Рішення:
// let twinkleStar = "Twinkle, twinkle, little star";
// let starRegex = /twinkle/gi;  // Change this line
// let result = twinkleStar.match(starRegex); // Change this line

/* 7 *******************************************************************************************************************/
// Зіставте будь-що з символом підстановки
// Іноді ви не будете (або не повинні) знати точні символи у своїх шаблонах. Придумування всіх слів, які відповідають, скажімо, орфографічній помилці, займе багато часу. На щастя, ви можете заощадити час, використовуючи символ підстановки:.

// Символ підстановки .відповідатиме будь-якому одному символу. Символ підстановки також називається dotі period. Ви можете використовувати символ підстановки, як і будь-який інший символ у регулярному виразі. Наприклад, якщо ви хочете зіставити hug, huh, hutі hum, ви можете використати регулярний вираз /hu./, щоб зіставити всі чотири слова.

// let humStr = "I'll hum a song";
// let hugStr = "Bear hug";
// let huRegex = /hu./;
// huRegex.test(humStr);
// huRegex.test(hugStr);
// Обидва ці testдзвінки повернуться true.

// Заповніть регулярний вираз unRegexтак, щоб він відповідав рядкам run, sun, fun, pun, nunі bun. Ваш регулярний вираз має використовувати символ підстановки.

//Рішення:
// let exampleStr = "Let's have fun with regular expressions!";
// let unRegex = /.un/;  // Change this line
// let result = unRegex.test(exampleStr);

/* 8 *******************************************************************************************************************/
// Зіставте один символ із кількома можливостями
// Ви дізналися, як зіставляти літеральні шаблони ( /literal/) і символ підстановки ( /./). Це крайнощі регулярних виразів, де один знаходить точні збіги, а інший – усе. Є варіанти, які є балансом між двома крайнощами.

// Ви можете шукати літеральний шаблон з певною гнучкістю за допомогою класів символів . Класи символів дозволяють визначити групу символів, які ви бажаєте зіставити, помістивши їх у квадратні ( [та ]) дужки.

// Наприклад, ви хочете відповідати bag, big, і bugале не bog. /b[aiu]g/Для цього можна створити регулярний вираз . Це [aiu]клас символів, який відповідатиме лише символам a, iабо u.

// let bigStr = "big";
// let bagStr = "bag";
// let bugStr = "bug";
// let bogStr = "bog";
// let bgRegex = /b[aiu]g/;
// bigStr.match(bgRegex);
// bagStr.match(bgRegex);
// bugStr.match(bgRegex);
// bogStr.match(bgRegex);
// У такому випадку чотири matchвиклики повертатимуть значення ["big"], ["bag"], ["bug"]та null.

// Використовуйте клас символів із голосними ( a, e, i, o, u) у своєму регулярному виразі vowelRegex, щоб знайти всі голосні в рядку quoteSample.

// Примітка. Переконайтеся, що голосні співпадають як у верхньому, так і в нижньому регістрі.

//Рішення:
// let quoteSample = "Beware of bugs in the above code; I have only proved it correct, not tried it.";
// let vowelRegex = /[aeiou]/gi; // Change this line
// let result = quoteSample.match(vowelRegex); // Change this line

/* 9 *******************************************************************************************************************/
// Зіставте букви алфавіту
// Ви бачили, як за допомогою наборів символів можна вказати групу символів для збігу, але це дуже багато введення, коли вам потрібно зіставити великий діапазон символів (наприклад, кожну літеру в алфавіті). На щастя, є вбудована функція, яка робить це коротким і простим.

// Усередині набору символів ви можете визначити діапазон символів для відповідності за допомогою символу дефіса: -.

// Наприклад, щоб зіставити малі літери aчерез eви, використовуйте [a-e].

// let catStr = "cat";
// let batStr = "bat";
// let matStr = "mat";
// let bgRegex = /[a-e]at/;
// catStr.match(bgRegex);
// batStr.match(bgRegex);
// matStr.match(bgRegex);
// У такому випадку три matchвиклики повертатимуть значення ["cat"], ["bat"], та null.

// Зіставте всі літери в рядку quoteSample.

// Примітка . Обов’язково збігайте як великі, так і малі літери.

//Рішення:
// let quoteSample = "The quick brown fox jumps over the lazy dog.";
// let alphabetRegex = /[a-z]/gi; // Change this line
// let result = quoteSample.match(alphabetRegex);  // Change this line

/*10 *******************************************************************************************************************/
// Зіставте цифри та букви алфавіту
// Використання дефіса ( -) для відповідності ряду символів не обмежується літерами. Він також працює для зіставлення діапазону чисел.

// Наприклад, /[0-5]/відповідає будь-якому числу між 0та 5, включаючи 0та 5.

// Крім того, можна комбінувати ряд літер і цифр в одному наборі символів.

// let jennyStr = "Jenny8675309";
// let myRegex = /[a-z0-9]/ig;
// jennyStr.match(myRegex);
// Створіть один регулярний вираз, який відповідає діапазону літер між hта sта діапазону чисел між 2та 6. Не забувайте включити відповідні позначки в регулярний вираз.

//Рішення:
// let quoteSample = "Blueberry 3.141592653s are delicious.";
// let myRegex = /[h-s2-6]/gi;// Change this line
// let result = quoteSample.match(myRegex);// Change this line

/* 11 *******************************************************************************************************************/
// Збіг окремих символів не вказано
// Наразі ви створили набір символів, яким ви хочете відповідати, але ви також можете створити набір символів, яким ви не хочете відповідати. Ці типи наборів символів називаються запереченими наборами символів .

// Щоб створити набір заперечених символів, ви розміщуєте символ вставки ( ^) після відкриваючої дужки та перед символами, які не потрібно збігати.

// Наприклад, /[^aeiou]/giвідповідає всім символам, які не є голосними. Зауважте, що такі символи, як ., !, [, та пробіли @, /збігаються – набір символів запереченої голосної не включає лише символи голосних.

// Створіть один регулярний вираз, який відповідає всім символам, які не є числами чи голосними. Не забувайте включити відповідні позначки в регулярний вираз.

//Рішення:
// let quoteSample = "3 blind mice.";
// let myRegex = /[^0-9aeiou]/gi; // Change this line
// let result = quoteSample.match(myRegex);// Change this line

/* 12 *******************************************************************************************************************/
// Зіставте символи, які зустрічаються один або кілька разів
// Іноді вам потрібно зіставити символ (або групу символів), який з’являється один або кілька разів поспіль. Це означає, що це відбувається принаймні один раз і може повторюватися.

// Ви можете використовувати +символ, щоб перевірити, чи це так. Пам’ятайте, символ або візерунок має бути присутнім послідовно. Тобто персонаж має повторювати один за одним.

// Наприклад, /a+/gзнайде один збіг у abcта поверне ["a"]. Через це +він також знайде один збіг aabcі повернеться ["aa"].

// Якби він замість цього перевіряв рядок abab, він знайшов би два збіги та повернувся, ["a", "a"]оскільки aсимволи не в рядку – bміж ними є символ. Нарешті, оскільки aв рядку немає bcd, він не знайде збігу.

// Ви хочете знайти збіги, коли літера sзустрічається один або кілька разів у Mississippi. Напишіть регулярний вираз, який використовує +знак

//Рішення:
// let difficultSpelling = "Mississippi";
// let myRegex = /s+/g; // Change this line
// let result = difficultSpelling.match(myRegex);

/*13 *******************************************************************************************************************/
// Зіставте символи, які зустрічаються нуль або більше разів
// Останнє завдання використовувало +знак плюс для пошуку символів, які зустрічаються один або кілька разів. Існує також опція, яка відповідає символам, які зустрічаються нуль або більше разів.

// Символом для цього є зірочка або зірка: *.

// let soccerWord = "gooooooooal!";
// let gPhrase = "gut feeling";
// let oPhrase = "over the moon";
// let goRegex = /go*/;
// soccerWord.match(goRegex);
// gPhrase.match(goRegex);
// oPhrase.match(goRegex);
// У такому випадку три matchвиклики повертатимуть значення ["goooooooo"], ["g"], та null.

// Для цього завдання chewieQuoteініціалізовано як рядок Aaaaaaaaaaaaaaaarrrgh!за лаштунками. Створіть регулярний вираз chewieRegex, який використовує *символ для відповідності символу верхнього регістру A, за яким слідують нуль або більше aсимволів нижнього регістру в chewieQuote. Вашому регулярному виразу не потрібні прапори чи класи символів, і воно не повинно збігатися з жодними іншими лапками.

//Рішення:
// let chewieQuote = "Aaaaaaaaaaaaaaaarrrgh!";
// let chewieRegex = /Aa*/; // Change this line
// let result = chewieQuote.match(chewieRegex);

/* 14 *******************************************************************************************************************/
// Знайдіть символи за допомогою відкладеної відповідності
// У регулярних виразах жадібний збіг знаходить найдовшу можливу частину рядка, яка відповідає шаблону регулярного виразу, і повертає її як збіг. Альтернатива називається відкладеним збігом, який знаходить найменшу можливу частину рядка, яка задовольняє шаблон регулярного виразу.

// Ви можете застосувати регулярний вираз /t[a-z]*i/до рядка "titanic". Цей регулярний вираз, в основному, є шаблоном, який починається з t, закінчується на i, і містить кілька літер між ними.

// Регулярні вирази за замовчуванням жадібні, тому відповідність повертатиме ["titani"]. Він знаходить найбільший підрядок, який відповідає шаблону.

// Однак ви можете використовувати ?символ, щоб змінити його на відкладене зіставлення. "titanic"зіставляється зі скоригованим регулярним виразом /t[a-z]*?i/повернення ["ti"].

// Примітка. Слід уникати аналізу HTML за допомогою регулярних виразів, але зіставлення шаблону рядка HTML за допомогою регулярних виразів є цілком нормальним.

// Виправте регулярний вираз /<.*>/, щоб повертати тег HTML <h1>, а не текст "<h1>Winter is coming</h1>". Пам’ятайте, що символ підстановки .в регулярному виразі відповідає будь-якому символу

//Рішення:
// let text = "<h1>Winter is coming</h1>";
// let myRegex = /<.*?>/;// Change this line
// let result = text.match(myRegex);

/* 15 *******************************************************************************************************************/
// Знайдіть одного чи кількох злочинців у полюванні
// Час зробити паузу та перевірити свої нові навички написання регулярних виразів. Група злочинців втекла з в'язниці і втекла, але ви не знаєте, скільки. Однак ви знаєте, що вони залишаються поруч, коли знаходяться поруч з іншими людьми. Ви повинні знайти всіх злочинців одночасно.

// Ось приклад, щоб переглянути, як це зробити:

// Регулярний вираз /z+/відповідає букві z, коли вона з’являється один або кілька разів поспіль. Він знайде збіги в усіх наступних рядках:

// "z"
// "zzzzzz"
// "ABCzzzz"
// "zzzzABC"
// "abczzzzzzzzzzzzzzzzzzzzzabc"
// Але він не знаходить збігів у наступних рядках, оскільки немає літерних zсимволів:

// ""
// "ABC"
// "abcabc"
// Напишіть жадібний регулярний вираз, який знаходить одного чи кількох злочинців у групі інших людей. Злочинця зображують великою літерою C

//Рішення:
// let reCriminals = /C+/; // Change this line

/*16 *******************************************************************************************************************/
// Зіставте шаблони початкових рядків
// Попередні виклики показали, що регулярні вирази можна використовувати для пошуку кількох збігів. Вони також використовуються для пошуку шаблонів у певних позиціях рядків.

// У попередньому завданні ви використовували символ введення ( ^) всередині набору символів, щоб створити заперечений набір символів у формі [^thingsThatWillNotBeMatched]. За межами набору символів каретка використовується для пошуку шаблонів на початку рядків.

// let firstString = "Ricky is first and can be found.";
// let firstRegex = /^Ricky/;
// firstRegex.test(firstString);
// let notFirst = "You can't find Ricky now.";
// firstRegex.test(notFirst);
// Перший testдзвінок повернувся true, а другий повернувся false.

// Використовуйте символ вставки в регулярному виразі, щоб знаходити Calлише на початку рядка rickyAndCal

//Рішення:
// let rickyAndCal = "Cal and Ricky both like racing.";
// let calRegex = /^Cal/;// Change this line
// let result = calRegex.test(rickyAndCal);

/* 17 *******************************************************************************************************************/
// Зіставте шаблони кінцевих рядків
// Під час останнього завдання ви навчилися використовувати символ вставки для пошуку шаблонів на початку рядків. Існує також спосіб пошуку шаблонів у кінці рядків.

// Ви можете шукати в кінці рядків за допомогою символу долара $в кінці регулярного виразу.

// let theEnding = "This is a never ending story";
// let storyRegex = /story$/;
// storyRegex.test(theEnding);
// let noEnding = "Sometimes a story will have to end";
// storyRegex.test(noEnding);
// Перший testдзвінок повернувся true, а другий повернувся false.

// Використовуйте символ прив'язки ( $), щоб відповідати рядку cabooseв кінці рядка caboose

//Рішення:
// let caboose = "The last car on a train is the caboose";
// let lastRegex = /caboose$/; // Change this line
// let result = lastRegex.test(caboose);

/* 18 *******************************************************************************************************************/
// Зіставте всі літери та цифри
// Використовуючи класи символів, ви могли шукати всі літери алфавіту за допомогою [a-z]. Цей тип класу символів досить поширений, тому для нього існує ярлик, хоча він також містить кілька додаткових символів.

// Найближчим класом символів у JavaScript, який відповідає алфавіту, є \w. Цей ярлик дорівнює [A-Za-z0-9_]. Цей клас символів відповідає великим і малим регістрам, а також цифрам. Зауважте, що цей клас символів також включає символ підкреслення ( _).

// let longHand = /[A-Za-z0-9_]+/;
// let shortHand = /\w+/;
// let numbers = "42";
// let varNames = "important_var";
// longHand.test(numbers);
// shortHand.test(numbers);
// longHand.test(varNames);
// shortHand.test(varNames);
// Усі чотири з цих testдзвінків повернуться true.

// Ці класи скорочених символів також відомі як класи скорочених символів .

// Використовуйте клас скорочених символів \w, щоб підрахувати кількість буквено-цифрових символів у різних цитатах і рядках

//Рішення:
// let quoteSample = "The five boxing wizards jump quickly.";
// let alphabetRegexV2 = /\w/g; // Change this line
// let result = quoteSample.match(alphabetRegexV2).length;

/* 19 *******************************************************************************************************************/
// Зіставте все, крім букв і цифр
// Ви дізналися, що можна використовувати ярлик для зіставлення буквено-цифрових символів [A-Za-z0-9_]за допомогою \w. Природний шаблон, який ви можете шукати, є протилежністю буквено-цифрових символів.

// Ви можете шукати протилежність до за \wдопомогою \W. Зауважте, що протилежний шаблон використовує велику літеру. Цей ярлик такий самий, як [^A-Za-z0-9_].

// let shortHand = /\W/;
// let numbers = "42%";
// let sentence = "Coding!";
// numbers.match(shortHand);
// sentence.match(shortHand);
// Перший matchвиклик повертає значення ["%"], а другий повертає ["!"].

// Використовуйте клас скорочених символів \W, щоб підрахувати кількість не буквено-цифрових символів у різних лапках і рядках.

//Рішення:
// let quoteSample = "The five boxing wizards jump quickly.";
// let nonAlphabetRegex = /\W/g;// Change this line
// let result = quoteSample.match(nonAlphabetRegex).length;

/*20 *******************************************************************************************************************/
// Зіставте всі числа
// Ви вивчили комбінації клавіш для поширених шаблонів рядків, наприклад буквено-цифрових. Інший поширений шаблон – пошук лише цифр або чисел.

// Ярлик для пошуку цифрових символів – це \d, з малими літерами d. Це дорівнює класу символів [0-9], який шукає один символ із будь-яким числом від нуля до дев’яти.

// Використовуйте клас скорочених символів, \dщоб підрахувати кількість цифр у назвах фільмів. Виписані числа («шість» замість 6) не зараховуються.

//Рішення:
// let movieName = "2001: A Space Odyssey";
// let numRegex = /\d/g;// Change this line
// let result = movieName.match(numRegex).length;

/* 21 *******************************************************************************************************************/
// Зіставте всі нечисла
// Останнє завдання показало, як шукати цифри за допомогою швидкого доступу \dз малими літерами d. Ви також можете шукати нецифри за допомогою аналогічного ярлика, який Dзамість цього використовує верхній регістр.

// Ярлик для пошуку нецифрових символів є \D. Це дорівнює класу символів [^0-9], який шукає один символ, який не є числом від нуля до дев’яти.

// Використовуйте клас скорочених символів для нецифр, \Dщоб підрахувати кількість нецифр у назвах фільмів.

//Рі1шення:
// let movieName = "2001: A Space Odyssey";
// let noNumRegex = /\D/g; // Change this line
// let result = movieName.match(noNumRegex).length;

/* 22 *******************************************************************************************************************/
// Обмежити можливі імена користувачів
// Імена користувачів використовуються всюди в Інтернеті. Саме вони надають користувачам унікальну ідентичність на їхніх улюблених сайтах.

// Вам потрібно перевірити всі імена користувачів у базі даних. Ось кілька простих правил, яких користувачі мають дотримуватися, створюючи ім’я користувача.

// Імена користувачів можуть використовувати лише буквено-цифрові символи.

// Єдині цифри в імені користувача мають бути в кінці. У кінці їх може бути нуль або більше. Ім'я користувача не може починатися з номера.

// Букви імені користувача можуть бути малими та великими.

// Імена користувачів мають складатися принаймні з двох символів. Ім’я користувача з двох символів може використовувати лише літери алфавіту як символи.

// Змініть регулярний вираз userCheckвідповідно до перерахованих вище обмежень.

//Рішення:
// let username = "JackOfAllTrades";
// let userCheck = /^[a-z][a-z]+\d*$|^[a-z]\d\d+$/i;
// let result = userCheck.test(username);

/*23 *******************************************************************************************************************/
// Збіг пробілів
// Поки що завдання охоплювали відповідність літер алфавіту та цифр. Ви також можете зіставити пробіли або пробіли між літерами.

// Ви можете шукати пробіли за допомогою \s, що є малим регістром s. Цей шаблон відповідає не лише пробілам, а й символам повернення каретки, символу табуляції, передачі форми та символу нового рядка. Ви можете вважати це подібним до класу символів [ \r\t\f\n\v].

// let whiteSpace = "Whitespace. Whitespace everywhere!"
// let spaceRegex = /\s/g;
// whiteSpace.match(spaceRegex);
// Цей matchдзвінок повернувся б [" ", " "].

// Змініть регулярний вираз countWhiteSpace, щоб шукати кілька пробілів у рядку

//Рішення:
// let sample = "Whitespace is important in separating words";
// let countWhiteSpace = /\s+/g; // Change this line
// let result = sample.match(countWhiteSpace);

/* 24 *******************************************************************************************************************/
// Збіг між символами, які не є пробілами
// Ви дізналися про пошук пробілів за допомогою \sмалої літери s. Ви також можете шукати все, крім пробілів.

// Шукайте не пробіли за допомогою \S, що є великим регістром s. Цей шаблон не відповідатиме пробілам, символам повернення каретки, символам табуляції, подачі форми та символам нового рядка. Ви можете думати, що це схоже на клас символів [^ \r\t\f\n\v].

// let whiteSpace = "Whitespace. Whitespace everywhere!"
// let nonSpaceRegex = /\S/g;
// whiteSpace.match(nonSpaceRegex).length;
// Значення, яке повертає .lengthметод, буде 32.

// Змініть регулярний вираз countNonWhiteSpace, щоб шукати кілька символів, відмінних від пробілів, у рядку

//Рішення:
// let sample = "Whitespace is important in separating words";
// let countNonWhiteSpace = /\S/g;   // Change this line
// let result = sample.match(countNonWhiteSpace);

/* 25 *******************************************************************************************************************/
// Укажіть верхню та нижню кількість збігів
// Пам’ятайте, що знак «плюс» використовується +для пошуку одного або кількох символів, а зірочка — *для пошуку нуля чи кількох символів. Це зручно, але іноді потрібно підібрати певний діапазон візерунків.

// Ви можете вказати нижню та верхню кількість шаблонів за допомогою специфікаторів кількості . Специфікатори кількості використовуються з фігурними дужками ( {і }). Ви ставите дві цифри між фігурними дужками - для нижньої та верхньої кількості візерунків.

// Наприклад, щоб відповідати лише літері, aщо з’являється між 3і 5разами в рядку ah, вашим регулярним виразом буде /a{3,5}h/.

// let A4 = "aaaah";
// let A2 = "aah";
// let multipleA = /a{3,5}h/;
// multipleA.test(A4);
// multipleA.test(A2);
// Перший testдзвінок повернувся true, а другий повернувся false.

// Змініть регулярний вираз ohRegex, щоб він відповідав усій фразі Oh noлише тоді, коли він має 3літеру 6' h.

//Рішення:
// let ohStr = "Ohhh no";
// let ohRegex = /Oh{3,6}\sno/; // Change this line
// let result = ohRegex.test(ohStr);

/* 26 *******************************************************************************************************************/
// Укажіть лише меншу кількість збігів
// Ви можете вказати нижню та верхню кількість шаблонів за допомогою специфікаторів кількості за допомогою фігурних дужок. Іноді потрібно вказати лише нижню кількість шаблонів без верхньої межі.

// Щоб указати лише меншу кількість візерунків, залиште перше число та кому.

// Наприклад, щоб відповідати лише рядку, hahлітера якого aз’являється принаймні 3разів, вашим регулярним виразом буде /ha{3,}h/.

// let A4 = "haaaah";
// let A2 = "haah";
// let A100 = "h" + "a".repeat(100) + "h";
// let multipleA = /ha{3,}h/;
// multipleA.test(A4);
// multipleA.test(A2);
// multipleA.test(A100);
// Порядком, три testвиклики повертатимуть true, false, і true.

// Змініть регулярний вираз haRegex, щоб він відповідав слову, Hazzahлише якщо воно містить чотири або більше букв z.

//Рішення:
// let haStr = "Hazzzzah";
// let haRegex = /Haz{4,}ah/; // Change this line
// let result = haRegex.test(haStr);

/* 27 *******************************************************************************************************************/
// Вкажіть точну кількість збігів
// Ви можете вказати нижню та верхню кількість шаблонів за допомогою специфікаторів кількості за допомогою фігурних дужок. Іноді вам потрібна лише певна кількість збігів.

// Щоб указати певну кількість візерунків, просто вставте це одне число у фігурні дужки.

// Наприклад, щоб зіставити лише слово hahз літерою a 3times, вашим регулярним виразом буде /ha{3}h/.

// let A4 = "haaaah";
// let A3 = "haaah";
// let A100 = "h" + "a".repeat(100) + "h";
// let multipleHA = /ha{3}h/;
// multipleHA.test(A4);
// multipleHA.test(A3);
// multipleHA.test(A100);
// Порядком, три testвиклики повертатимуть false, true, і false.

// Змініть регулярний вираз timRegex, щоб він відповідав слову Timberлише тоді, коли воно містить чотири літери m

//Рішення:
// let timStr = "Timmmmber";
// let timRegex = /Tim{4}ber/; // Change this line
// let result = timRegex.test(timStr);

/*28 *******************************************************************************************************************/
// Перевірте всі або жодного
// Іноді шаблони, які ви хочете шукати, можуть мати частини, які можуть існувати або не існувати. Проте все ж може бути важливо їх перевірити.

// Ви можете вказати можливе існування елемента за допомогою знака питання ?. Це перевіряє нуль або один із попередніх елементів. Ви можете думати про цей символ як про те, що попередній елемент необов’язковий.

// Наприклад, є невеликі відмінності в американській і британській англійській, і ви можете використовувати знак питання, щоб узгодити обидва варіанти написання.

// let american = "color";
// let british = "colour";
// let rainbowRegex= /colou?r/;
// rainbowRegex.test(american);
// rainbowRegex.test(british);
// Обидва варіанти використання методу testповернуть true.

// Змініть регулярний вираз favRegex, щоб відповідати американській англійській ( favorite) і британській англійській ( favourite) версіям слова

//Рішення:
// let favWord = "favorite";
// let favRegex = /favou?rite/; // Change this line
// let result = favRegex.test(favWord);

/* 29 *******************************************************************************************************************/
// Позитивний і негативний прогноз
// Попередні пошуки — це шаблони, які повідомляють JavaScript продивлятися у вашому рядку, щоб перевірити шаблони далі. Це може бути корисним, якщо ви хочете шукати кілька шаблонів в одному рядку.

// Існує два види прогнозів: позитивний прогноз і негативний прогноз .

// Позитивний прогноз перевіряє наявність елемента в шаблоні пошуку, але не відповідає йому. Позитивний попередній перегляд використовується як (?=...)необхідна ...частина, яка не відповідає.

// З іншого боку, негативний прогноз перевіряє, чи немає елемента в шаблоні пошуку. Негативний прогноз використовується як (?!...)те, де ...є шаблон, який ви не хочете мати. Решта шаблону повертається, якщо від’ємна частина попереднього перегляду відсутня.

// Попередні прогнози трохи заплутані, але деякі приклади допоможуть.

// let quit = "qu";
// let noquit = "qt";
// let quRegex= /q(?=u)/;
// let qRegex = /q(?!u)/;
// quit.match(quRegex);
// noquit.match(qRegex);
// Обидва ці matchдзвінки повернуться ["q"].

// Більш практичним використанням попереднього перегляду є перевірка двох або більше шаблонів в одному рядку. Ось (наївно) проста перевірка пароля, яка шукає від 3 до 6 символів і принаймні одне число:

// let password = "abc123";
// let checkPass = /(?=\w{3,6})(?=\D*\d)/;
// checkPass.test(password);
// Використовуйте попередній перегляд, pwRegexщоб зіставляти паролі, довжина яких перевищує 5 символів і дві послідовні цифри.

//Рішення:
// let sampleWord = "astronaut";
// let pwRegex = /(?=\w{6,})(?=\D*\d{2})/; // Change this line
// let result = pwRegex.test(sampleWord);

/* 30 *******************************************************************************************************************/
// Перевірте наявність змішаного групування символів
// Іноді ми хочемо перевірити групи символів за допомогою регулярного виразу, а для досягнення цього ми використовуємо круглі дужки ().

// Якщо ви хочете знайти або Penguinабо Pumpkinв рядку, ви можете використати такий регулярний вираз:/P(engu|umpk)in/g

// Потім перевірте, чи є потрібні групи рядків у тестовому рядку за допомогою методу test().

// let testStr = "Pumpkin";
// let testRegex = /P(engu|umpk)in/;
// testRegex.test(testStr);
// Цей testметод повертає true.

// Виправте регулярний вираз таким чином, щоб він перевіряв імена Franklin Rooseveltабо Eleanor Rooseveltз урахуванням регістру, і він повинен робити поступки для імен по батькові.

// Потім виправте код, щоб регулярний вираз, який ви створили, перевірявся myStringта повертався або trueабо залежно від того, чи збігається регулярний вираз.false

//Рішення:
// let myString = "Eleanor Roosevelt";
// let myRegex = /(Franklin|Eleanor) (([A-Z]\.?|[A-Z][a-z]+) )?Roosevelt/;// Change this line
// let result = myRegex.test(myString);// Change this line

/* 31 *******************************************************************************************************************/
// Повторне використання шаблонів за допомогою груп захоплення
// Скажімо, ви хочете знайти слово, яке зустрічається кілька разів, як показано нижче.

// let repeatStr = "row row row your boat";
// Ви можете використовувати /row row row/, але що, якщо ви не знаєте конкретного слова, яке повторюється? Групи захоплення можна використовувати для пошуку повторюваних підрядків.

// Групи захоплення створюються шляхом укладення шаблону регулярного виразу, який потрібно захопити, у круглі дужки. У цьому випадку мета полягає в тому, щоб захопити слово, що складається з буквено-цифрових символів, щоб група захоплення була \w+укладена в дужки: /(\w+)/.

// Підрядок, який відповідає групі, зберігається в тимчасовій "змінній", доступ до якої можна отримати в тому самому регулярному виразі, використовуючи зворотну косу риску та номер групи захоплення (наприклад, \1). Групи захоплення автоматично нумеруються за положенням відкриваючих дужок (зліва направо), починаючи з 1.

// Наведений нижче приклад відповідає слову, яке зустрічається тричі через пробіли:

// let repeatRegex = /(\w+) \1 \1/;
// repeatRegex.test(repeatStr); // Returns true
// repeatStr.match(repeatRegex); // Returns ["row row row", "row"]
// Використання .match()методу для рядка поверне масив із відповідним підрядком разом із захопленими групами.

// Використовуйте групи захоплення, щоб reRegexзіставити рядок, який складається лише з однакового числа, повтореного рівно три рази, розділених одиночними пробілами.


//Рішення:
// let repeatNum = "42 42 42";
// let reRegex = /^(\d+) \1 \1$/; // Change this line
// let result = reRegex.test(repeatNum);

/* 32 *******************************************************************************************************************/
// Використовуйте групи захоплення для пошуку та заміни
// Пошук корисний. Однак ви можете зробити пошук ще потужнішим, коли він також змінює (або замінює) текст, який вам відповідає.

// Ви можете шукати та замінювати текст у рядку за допомогою .replace()on a string. Вхідні дані для .replace()– це спочатку шаблон регулярного виразу, який ви хочете знайти. Другим параметром є рядок для заміни збігу або функція, яка щось виконує.

// let wrongText = "The sky is silver.";
// let silverRegex = /silver/;
// wrongText.replace(silverRegex, "blue");
// Виклик replaceповертає рядок The sky is blue..

// Ви також можете отримати доступ до груп захоплення в рядку заміни зі знаками долара ( $).

// "Code Camp".replace(/(\w+)\s(\w+)/, '$2 $1');
// Виклик replaceповертає рядок Camp Code.

// Напишіть регулярний вираз, fixRegexвикористовуючи три групи захоплення, які шукатимуть кожне слово в рядку one two three. Потім оновіть replaceTextзмінну, щоб замінити one two threeїї рядком three two one, і призначте результат змінній result. Переконайтеся, що ви використовуєте групи захоплення в рядку заміни за допомогою $синтаксису знака долара ( )

//Рішення:
// let str = "one two three";
// let fixRegex = /(\w+)\s(\w+)\s(\w+)/;  // Change this line
// let replaceText = '$3 $2 $1';// Change this line
// let result = str.replace(fixRegex, replaceText);

/*33 *******************************************************************************************************************/
// Видаліть пробіли з початку та кінця
// Іноді пробіли навколо рядків небажані, але є. Типовою обробкою рядків є видалення пробілів на початку та в кінці.

// Напишіть регулярний вираз і використовуйте відповідні методи рядків, щоб видалити пробіли на початку та в кінці рядків.

// Примітка: цей String.prototype.trim()метод буде працювати тут, але вам потрібно буде виконати це завдання за допомогою регулярних виразів

//Рішення:
// let hello = "   Hello, World!  ";
// let wsRegex = /^\s+|\s+$/g;  // Change this line
// let result = hello.replace(wsRegex, ''); // Change this line
